import * as fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { toCamelCase, toPascalCase } from '../src/lib/utils.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

async function generateBaseClient() {
	const IGNORE_FILES = ['oauth.ts', 'common-schemas.ts']
	const BASE_CLIENT_FILE = path.join(__dirname, '../src/v2/client/base.ts')
	const TYPES_DIR = path.join(__dirname, '../src/v2/types')

	// Get all type files
	const files = fs.readdirSync(TYPES_DIR)
	const typeFiles = files.filter(
		(f) => f.endsWith('.ts') && !IGNORE_FILES.includes(f),
	)

	const schemaFiles = typeFiles
		.map((file) => {
			const fileName = file.replace('.ts', '')
			const camelName = toCamelCase(fileName)
			const pascalName = toPascalCase(fileName)
			return { pascalName, camelName, fileName }
		})
		.sort((a, b) => a.camelName.localeCompare(b.camelName))

	// Generate import statements
	const importStatements = schemaFiles
		.map((file) => {
			return `import type { paths as ${file.pascalName}Paths } from '../types/${file.fileName}'`
		})
		.join('\n')

	const propertyDeclarations = schemaFiles
		.map((file) => {
			return `\t${file.camelName}: AnyClient<${file.pascalName}Paths>`
		})
		.join('\n')

	// Generate method implementations
	const generateMethods = schemaFiles
		.map((file) => {
			const comment = `\t\t/**\n\t\t * ${file.camelName} client implementation.\n\t\t */`
			const methodImpl = `\t\tthis.${file.camelName} = createClientMaybeAuth<${file.pascalName}Paths, THeaders>(this._clientConfig, authHeaders)`

			return `${comment}\n${methodImpl}`
		})
		.join('\n')

	const classContent = `// This file is generated by the generate-base-client.ts script.
// Do not edit directly.

import type { Client } from 'openapi-fetch'
import createClient from 'openapi-fetch'
import type { AnyOauthClient, AnyClient } from './client-type-helpers'
import { createClientMaybeAuth } from './client-type-helpers'
import type { HighLevelClientConfig } from './default'
import { DEFAULT_V2_BASE_URL } from './default'
import type { AUTH_HEADERS } from './types'

// type imports
import type { paths as OauthPaths } from '../types/oauth'
${importStatements}

/**
 * Base implementation for HighLevel API client.
 * Provides endpoint clients for each API domain with conditional types based on THeaders.
 *
 * When THeaders is undefined, auth headers are required on each request.
 * When THeaders is AUTH_HEADERS, auth headers are pre-configured and optional on requests.
 */
export class BaseHighLevelClient<
\tTHeaders extends AUTH_HEADERS | undefined = undefined,
> {
\t/**
\t * Exposed config object for convenience.
\t */
\t_clientConfig: HighLevelClientConfig
\toauth: AnyOauthClient

${propertyDeclarations}

\tconstructor(clientConfig?: HighLevelClientConfig, authHeaders?: THeaders) {
\t\tthis._clientConfig = clientConfig || {
\t\t\tbaseUrl: DEFAULT_V2_BASE_URL,
\t\t}
\t\tif (authHeaders) {
\t\t\tthis._clientConfig.headers = {
\t\t\t\t...this._clientConfig.headers,
\t\t\t\t...authHeaders,
\t\t\t}
\t\t}

\t\t// base oauth client
\t\tthis.oauth = createClient<OauthPaths>(this._clientConfig)

\t\t// generate methods
${generateMethods}
\t}
}
`

	fs.writeFileSync(BASE_CLIENT_FILE, classContent, 'utf-8')
	console.log(
		`âœ“ Successfully generated BaseHighLevelClient in ${BASE_CLIENT_FILE.replace(path.join(__dirname, '..'), '')}`,
	)
}

generateBaseClient().catch(console.error)

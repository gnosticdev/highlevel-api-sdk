import path from 'node:path'
import kleur from 'kleur'
import { toCamelCase, toPascalCase } from '../src/lib/utils'

if (import.meta.main) {
	await generateBaseClient()
}

/**
 * Generates the BaseHighLevelClient class implementation.
 * This script reads all type files and generates getter methods for each client property.
 */
export async function generateBaseClient() {
	const IGNORE_FILES = ['oauth.ts', 'common-schemas.ts']
	const BASE_CLIENT_FILE = path.join(process.cwd(), 'src/v2/client/base.ts')

	// Get all type files using bun.Glob
	const glob = new Bun.Glob('src/v2/types/openapi/*.ts')
	const typeFiles = await Array.fromAsync(
		glob.scan({ absolute: true, onlyFiles: true }),
	)

	const schemaFiles = typeFiles
		.filter((file) => {
			const basename = path.basename(file)
			return !IGNORE_FILES.includes(basename)
		})
		.map((file) => {
			const fileName = path.basename(file).replace('.ts', '')
			const camelName = toCamelCase(fileName)
			const pascalName = toPascalCase(fileName)
			return { pascalName, camelName, fileName }
		})
		.sort((a, b) => a.camelName.localeCompare(b.camelName))

	// Generate import statements
	const importStatements = schemaFiles
		.map((file) => {
			return `import type { paths as ${file.pascalName}Paths } from '../types/openapi/${file.fileName}'`
		})
		.join('\n')

	// Note: Properties are declared via getters, not as separate properties
	// to avoid TypeScript complexity errors with conditional types

	const propertyDeclarations = schemaFiles
		.map((file) => {
			return `${file.camelName}: Client<${file.pascalName}Paths> | ClientWithAuth<${file.pascalName}Paths>`
		})
		.join('\n\n\t')

	// Generate getter method implementations
	const generateMethods = schemaFiles
		.map((file) => {
			const comment = `/**
 * ${file.camelName} client implementation.
 */`
			const methodImpl = `this.${file.camelName} = createClientMaybeAuth<${file.pascalName}Paths>(
			AUTH_HEADERS,
			this._clientConfig,
		)`

			return `${comment}\n\t${methodImpl}`
		})
		.join('\n\n\t')

	const classContent = `
// This file is generated by the ${import.meta.file} script.
// Do not edit directly.

import type { Client } from 'openapi-fetch'
import createClient from 'openapi-fetch'
import type { AnyHighLevelInterface, AnyOauthClient } from './client-type-helpers'
import type { AUTH_HEADERS, ClientWithAuth } from './types'
import type { HighLevelClientConfig } from './default'
import { DEFAULT_V2_BASE_URL } from './default'
import { createClientMaybeAuth } from './client-type-helpers'

// type imports
import type { paths as OauthPaths } from '../types/openapi/oauth'
${importStatements}


/**
 * Base implementation of HighLevelClientInterface.
 * Provides getter methods for each client property with conditional types based on THeaders.
 */
export class BaseHighLevelClient<
	THeaders extends AUTH_HEADERS | undefined = undefined,
> implements AnyHighLevelInterface
{
	/**
	 * Exposed config object for convenience.
	 */
	_clientConfig: HighLevelClientConfig
	oauth: AnyOauthClient

    ${propertyDeclarations}

	constructor(
		clientConfig?: HighLevelClientConfig,
		AUTH_HEADERS?: THeaders,
	) {
		this._clientConfig = clientConfig || {
			baseUrl: DEFAULT_V2_BASE_URL,
		}
		if (AUTH_HEADERS) {
			this._clientConfig.headers = {
				...this._clientConfig.headers,
				...AUTH_HEADERS,
			}
		}

		// base oauth client
		this.oauth = createClient<OauthPaths>(this._clientConfig)

        // generate methods
        ${generateMethods}

	}

}
`.trim()

	await Bun.write(BASE_CLIENT_FILE, classContent)
	console.log(
		kleur.green(
			`Successfully generated BaseHighLevelClient in ${BASE_CLIENT_FILE.replace(process.cwd(), '')}`,
		),
	)
}

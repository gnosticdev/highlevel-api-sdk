import path from 'node:path'
import kleur from 'kleur'
import { toCamelCase, toPascalCase } from '../src/lib/utils'

if (import.meta.main) {
	await generateBaseClient()
}

/**
 * Generates the BaseHighLevelClient class implementation.
 * This script reads all type files and generates getter methods for each client property.
 */
export async function generateBaseClient() {
	const IGNORE_FILES = ['oauth.ts', 'common-schemas.ts']
	const BASE_CLIENT_FILE = path.join(process.cwd(), 'src/v2/client/base.ts')

	// Get all type files using bun.Glob
	const glob = new Bun.Glob('src/v2/types/*.ts')
	const typeFiles = await Array.fromAsync(
		glob.scan({ absolute: true, onlyFiles: true }),
	)

	const schemaFiles = typeFiles
		.filter((file) => {
			const basename = path.basename(file)
			return !IGNORE_FILES.includes(basename)
		})
		.map((file) => {
			const fileName = path.basename(file).replace('.ts', '')
			const camelName = toCamelCase(fileName)
			const pascalName = toPascalCase(fileName)
			return { pascalName, camelName, fileName }
		})
		.sort((a, b) => a.camelName.localeCompare(b.camelName))

	// Generate import statements
	const importStatements = schemaFiles
		.map((file) => {
			return `import type { paths as ${file.pascalName}Paths } from '../types/${file.fileName}'`
		})
		.join('\n')

	// Generate property declarations
	const propertyDeclarations = schemaFiles
		.map((file) => {
			return `${file.camelName}: Client<${file.pascalName}Paths>`
		})
		.join('\n\t')

	// Generate method implementations
	const generateMethods = schemaFiles
		.map((file) => {
			const comment = `/**
		 * ${file.camelName} client implementation.
		 */`
			const methodImpl = `this.${file.camelName} = createClientMaybeAuth<${file.pascalName}Paths, AUTH_HEADERS | undefined>(
			authHeaders,
			this._clientConfig,
		) as Client<${file.pascalName}Paths>`

			return `${comment}\n\t\t${methodImpl}`
		})
		.join('\n\t\t')

	const classContent = `
// This file is generated by the ${import.meta.file} script.
// Do not edit directly.

import type { Client } from 'openapi-fetch'
import createClient from 'openapi-fetch'
import type { AccessType } from '../../lib/type-utils'
import type { HighLevelClientInterface } from '..'
import type { DefaultOauthClient, OauthClientImpl } from '../oauth/impl'
${importStatements}
import type { HighLevelClientConfig } from './default'
import { DEFAULT_V2_BASE_URL } from './default'
import { createClientMaybeAuth } from './client-type-helpers'
import type { AUTH_HEADERS } from './types'
// type imports
import type { paths as OauthPaths } from '../types/oauth'

/**
 * Base implementation for HighLevel API client.
 * Provides endpoint clients for each API domain.
 */
export class BaseHighLevelClient<
	T extends AccessType,
	TOAuth extends DefaultOauthClient | OauthClientImpl<T>,
> implements HighLevelClientInterface<T, TOAuth>
{
	/**
	 * Exposed config object for convenience.
	 */
	_clientConfig: HighLevelClientConfig
	oauth: TOAuth

	${propertyDeclarations}

	constructor(
		clientConfig?: HighLevelClientConfig,
		authHeaders?: AUTH_HEADERS,
	) {
		this._clientConfig = {
			...clientConfig,
			baseUrl: clientConfig?.baseUrl ?? DEFAULT_V2_BASE_URL,
		}
		if (authHeaders) {
			this._clientConfig.headers = {
				...this._clientConfig.headers,
				...authHeaders,
			}
		}

		// base oauth client
		this.oauth = createClient<OauthPaths>(this._clientConfig) as TOAuth

		// generate methods
		${generateMethods}
	}
}
`.trim()

	await Bun.write(BASE_CLIENT_FILE, classContent)
	console.log(
		kleur.green(
			`Successfully generated BaseHighLevelClient in ${BASE_CLIENT_FILE.replace(process.cwd(), '')}`,
		),
	)
	await Bun.$`bun biome check ${BASE_CLIENT_FILE} --write --unsafe`
}
